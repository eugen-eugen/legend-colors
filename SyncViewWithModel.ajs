/*
 * Sync View With Model
 *
 * This script keeps views in sync with the model by adding newly related elements.
 *
 * Only elements marked as "Kernelement" (core elements) will attract new elements.
 * An element is marked as Kernelement if it's a child of a visual group
 * with property "Kernelement" set.
 *
 * If the property value is "recursive", all children (recursively) are attractors,
 * following the visual parent/child hierarchy on the view.
 * If the property has no value or any other value, only direct children are attractors.
 *
 * A meta-model can be defined on the view by:
 * 1. Creating a visual group with property "meta", OR
 * 2. Placing a view reference element on the view that points to another view with property "meta".
 *    In this case, all elements on the referenced view are considered part of the meta-model.
 * The meta-model defines which relationships are allowed between which types of elements.
 * Only relationships allowed by the meta-model will be followed for synchronization.
 * Aggregation and composition in the meta-model are treated as equivalent.
 *
 * For each attractor element, the script checks if there are directly related elements
 * in the model that are not yet visualized on the view. Such elements are added to a
 * "New Elements" group at the top-left of the view, along with their relationships
 * to the attractor elements.
 *
 * Elements with property "no-auto-sync" (with or without value) are excluded from
 * automatic synchronization.
 *
 * Views that receive new elements get a "review-" prefix in their name.
 *
 * DEBUG: Set property "debug" with value "true" on any Kernelement visual group to enable
 *        detailed logging information in the console.
 *        For meta-model debugging: set "debug=true" on the meta-model visual group,
 *        or on the referenced view if using the view reference approach.
 *
 * (c) Y. Moldawski, 2026
 */

// Load helper libraries
load(__DIR__ + "lib/attractors.js");
load(__DIR__ + "lib/metamodel.js");

/**
 * Checks if any Kernelement group in the view has debug enabled
 * @param {View} view - The view to check
 * @returns {boolean} True if any Kernelement group has property "debug" with value "true"
 */
function hasDebugEnabled(view) {
  var debugEnabled = false;
  $(view)
    .find("diagram-model-group")
    .each(function (group) {
      var kernelementValue = group.prop("Kernelement");
      if (kernelementValue != null) {
        var debugValue = group.prop("debug");
        if (debugValue === "true") {
          debugEnabled = true;
          return false; // break
        }
      }
    });
  return debugEnabled;
}

/**
 * Gets all model elements that are directly related to the given element
 * Returns array of objects: {element: element, relationship: relationship}
 */
function getRelatedElementsWithRelationships(element) {
  var relatedElements = [];
  var seen = {};

  // Get relationships where element is source
  $(element)
    .rels()
    .each(function (rel) {
      var target = rel.target;
      if (!seen[target.id]) {
        relatedElements.push({ element: target, relationship: rel });
        seen[target.id] = true;
      }
    });

  // Get relationships where element is target
  $(element)
    .inRels()
    .each(function (rel) {
      var source = rel.source;
      if (!seen[source.id]) {
        relatedElements.push({ element: source, relationship: rel });
        seen[source.id] = true;
      }
    });

  return relatedElements;
}

/**
 * Checks if a model element is already visualized on the view
 */
function isElementOnView(view, element) {
  var found = false;
  $(view)
    .find("element")
    .each(function (visualElement) {
      if (visualElement.concept.id === element.id) {
        found = true;
        return false; // break
      }
    });
  return found;
}

/**
 * Finds a visual object for a given model element on a view
 */
function findVisualObjectForElement(view, element) {
  var result = null;
  $(view)
    .find("element")
    .each(function (visualElement) {
      if (visualElement.concept.id === element.id) {
        result = visualElement;
        return false; // break
      }
    });
  return result;
}

/**
 * Finds or creates a "New Elements" group at the top-left of the view
 */
function findOrCreateNewElementsGroup(view, debugEnabled) {
  var newElementsGroup = null;

  // Try to find existing group
  $(view)
    .find("diagram-model-group")
    .each(function (group) {
      if (group.name === "New Elements") {
        newElementsGroup = group;
        return false; // break
      }
    });

  // Create if not found
  if (!newElementsGroup) {
    newElementsGroup = view.createObject("diagram-model-group", 10, 10, 200, 100);
    newElementsGroup.name = "New Elements";
    if (debugEnabled) {
      console.log("  Created 'New Elements' group");
    }
  }

  return newElementsGroup;
}

/**
 * Processes a single view
 */
function processView(view, debugEnabled) {
  if (debugEnabled) {
    console.log("\nProcessing view: " + view.name);
  }

  // Extract meta-model if present
  var metaModel = extractMetaModel(view);
  if (debugEnabled) {
    if (metaModel) {
      console.log("  Meta-model enabled for this view");
    } else {
      console.log("  No meta-model found (all relationships allowed)");
    }
  }

  // Get all attractors in this view (passing meta-model for recursive collection)
  var attractors = getAttractors(view, metaModel, isRelationshipAllowed, debugEnabled);

  if (attractors.length === 0) {
    if (debugEnabled) {
      console.log("  No Kernelement groups found, skipping view");
    }
    return;
  }

  if (debugEnabled) {
    console.log("  Found " + attractors.length + " attractor(s)");
  }

  // Collect all missing elements and relationships to add
  var missingElements = [];
  var seenMissing = {};
  var relationshipsToAdd = []; // Array of {relationship, attractorElement}

  attractors.forEach(function (visualAttractor) {
    var attractorElement = visualAttractor.concept;
    var relatedInfo = getRelatedElementsWithRelationships(attractorElement);

    relatedInfo.forEach(function (info) {
      var relatedElement = info.element;
      var relationship = info.relationship;

      // Check if element has "no-auto-sync" property - skip if it does
      if (relatedElement.prop("no-auto-sync") != null) {
        if (debugEnabled) {
          console.log("    Skipping " + relatedElement.name + " (has no-auto-sync property)");
        }
        return; // Skip this element
      }

      // Check if relationship is allowed by meta-model
      // Use the actual source and target from the relationship, not assumptions
      if (!isRelationshipAllowed(relationship.source, relationship.target, relationship, metaModel)) {
        if (debugEnabled) {
          console.log(
            "    Skipping " +
              relatedElement.name +
              " (relationship " +
              relationship.type +
              " not allowed by meta-model)",
          );
        }
        return;
      }

      // Check if this element is not yet on the view
      if (!isElementOnView(view, relatedElement)) {
        if (!seenMissing[relatedElement.id]) {
          missingElements.push(relatedElement);
          seenMissing[relatedElement.id] = true;
        }
        // Store the relationship to add later
        relationshipsToAdd.push({
          relationship: relationship,
          attractorElement: attractorElement,
        });
      }
    });
  });

  if (missingElements.length === 0) {
    if (debugEnabled) {
      console.log("  No missing elements found");
    }
    return;
  }

  if (debugEnabled) {
    console.log("  Found " + missingElements.length + " missing element(s) to add");
  }

  // Find or create "New Elements" group
  var newElementsGroup = findOrCreateNewElementsGroup(view, debugEnabled);

  // Add missing elements to the group
  var xOffset = 20;
  var yOffset = 30;
  var elementWidth = 120;
  var elementHeight = 55;
  var spacing = 10;

  missingElements.forEach(function (element, index) {
    var x = xOffset;
    var y = yOffset + index * (elementHeight + spacing);

    var visualElement = newElementsGroup.add(element, x, y, elementWidth, elementHeight);
    if (debugEnabled) {
      console.log("    Added: " + element.name + " (" + element.type + ")");
    }
  });

  // Adjust group size to fit all elements
  var groupHeight = yOffset + missingElements.length * (elementHeight + spacing) + 20;
  newElementsGroup.bounds = {
    x: 10,
    y: 10,
    width: elementWidth + 2 * xOffset,
    height: Math.max(groupHeight, 100),
  };

  // Add visual connections for the relationships
  if (debugEnabled) {
    console.log("  Adding relationships...");
  }
  var addedConnections = 0;
  relationshipsToAdd.forEach(function (relInfo) {
    var relationship = relInfo.relationship;
    var sourceElement = relationship.source;
    var targetElement = relationship.target;

    // Find visual objects for source and target
    var sourceVisual = findVisualObjectForElement(view, sourceElement);
    var targetVisual = findVisualObjectForElement(view, targetElement);

    if (sourceVisual && targetVisual) {
      // Add the visual connection
      view.add(relationship, sourceVisual, targetVisual);
      addedConnections++;
    }
  });
  if (debugEnabled) {
    console.log("  Added " + addedConnections + " relationship(s)");
  }

  // Add "review-" prefix to view name if not already present
  if (!view.name.startsWith("review-")) {
    view.name = "review-" + view.name;
    if (debugEnabled) {
      console.log("  Renamed view to: " + view.name);
    }
  }
}

// Main execution
var views = $("archimate-diagram-model");

// Check if any view has debug enabled
var debugEnabled = false;
views.each(function (view) {
  if (hasDebugEnabled(view)) {
    debugEnabled = true;
    return false; // break
  }
});

// Only show console if debug is enabled
if (debugEnabled) {
  console.show();
  console.clear();
  console.log("Starting Sync View With Model script...");
  console.log("\nFound " + views.size() + " ArchiMate view(s) to process\n");
}

views.each(function (view) {
  var viewDebug = hasDebugEnabled(view);
  processView(view, viewDebug);
});

if (debugEnabled) {
  console.log("\n=== Sync completed ===");
}
