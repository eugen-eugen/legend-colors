/*
 * Sync View With Model
 *
 * This script keeps views in sync with the model by adding newly related elements.
 *
 * Only elements marked as "Kernelement" (core elements) will attract new elements.
 * An element is marked as Kernelement if it's a child of a visual group
 * with property "Kernelement" set. 
 * 
 * If the property value is "recursive", all children (recursively) are attractors.
 * If the property has no value or any other value, only direct children are attractors.
 *
 * For each attractor element, the script checks if there are directly related elements
 * in the model that are not yet visualized on the view. Such elements are added to a
 * "New Elements" group at the top-left of the view, along with their relationships
 * to the attractor elements.
 *
 * Elements with property "no-auto-sync" (with or without value) are excluded from
 * automatic synchronization.
 *
 * Views that receive new elements get a "review-" prefix in their name.
 *
 * (c) Y. Moldawski, 2026
 */

console.show();
console.clear();
console.log("Starting Sync View With Model script...");

/**
 * Recursively collects all visual objects that are children of a given parent
 */
function collectChildVisualObjectsRecursive(parent, result) {
  if (!result) {
    result = [];
  }

  $(parent)
    .children()
    .each(function (child) {
      // Add the child if it's an element (has a concept)
      if (child.concept) {
        result.push(child);
      }
      // Recursively process children of this child
      collectChildVisualObjectsRecursive(child, result);
    });

  return result;
}

/**
 * Collects only direct child visual objects (non-recursive)
 */
function collectDirectChildVisualObjects(parent) {
  var result = [];

  $(parent)
    .children()
    .each(function (child) {
      // Add the child if it's an element (has a concept)
      if (child.concept) {
        result.push(child);
      }
    });

  return result;
}

/**
 * Gets all visual objects that are attractors (children of Kernelement groups)
 */
function getAttractors(view) {
  var attractors = [];

  // Find all visual groups with property "Kernelement" (regardless of value)
  $(view)
    .find("diagram-model-group")
    .each(function (group) {
      var kernelementValue = group.prop("Kernelement");
      if (kernelementValue != null) {
        console.log("  Found Kernelement group: " + group.name + " (Kernelement=" + kernelementValue + ")");
        
        // Check if recursive collection is requested
        var children;
        if (kernelementValue === "recursive") {
          children = collectChildVisualObjectsRecursive(group);
          console.log("    Using recursive collection");
        } else {
          children = collectDirectChildVisualObjects(group);
          console.log("    Using direct children only");
        }
        
        attractors = attractors.concat(children);
      }
    });

  return attractors;
}

/**
 * Gets all model elements that are directly related to the given element
 * Returns array of objects: {element: element, relationship: relationship}
 */
function getRelatedElementsWithRelationships(element) {
  var relatedElements = [];
  var seen = {};

  // Get relationships where element is source
  $(element)
    .rels()
    .each(function (rel) {
      var target = rel.target;
      if (!seen[target.id]) {
        relatedElements.push({element: target, relationship: rel});
        seen[target.id] = true;
      }
    });

  // Get relationships where element is target
  $(element)
    .inRels()
    .each(function (rel) {
      var source = rel.source;
      if (!seen[source.id]) {
        relatedElements.push({element: source, relationship: rel});
        seen[source.id] = true;
      }
    });

  return relatedElements;
}

/**
 * Checks if a model element is already visualized on the view
 */
function isElementOnView(view, element) {
  var found = false;
  $(view)
    .find("element")
    .each(function (visualElement) {
      if (visualElement.concept.id === element.id) {
        found = true;
        return false; // break
      }
    });
  return found;
}

/**
 * Finds a visual object for a given model element on a view
 */
function findVisualObjectForElement(view, element) {
  var result = null;
  $(view)
    .find("element")
    .each(function (visualElement) {
      if (visualElement.concept.id === element.id) {
        result = visualElement;
        return false; // break
      }
    });
  return result;
}

/**
 * Finds or creates a "New Elements" group at the top-left of the view
 */
function findOrCreateNewElementsGroup(view) {
  var newElementsGroup = null;

  // Try to find existing group
  $(view)
    .find("diagram-model-group")
    .each(function (group) {
      if (group.name === "New Elements") {
        newElementsGroup = group;
        return false; // break
      }
    });

  // Create if not found
  if (!newElementsGroup) {
    newElementsGroup = view.createObject(
      "diagram-model-group",
      10,
      10,
      200,
      100,
    );
    newElementsGroup.name = "New Elements";
    console.log("  Created 'New Elements' group");
  }

  return newElementsGroup;
}

/**
 * Processes a single view
 */
function processView(view) {
  console.log("\nProcessing view: " + view.name);

  // Get all attractors in this view
  var attractors = getAttractors(view);

  if (attractors.length === 0) {
    console.log("  No Kernelement groups found, skipping view");
    return;
  }

  console.log("  Found " + attractors.length + " attractor(s)");

  // Collect all missing elements and relationships to add
  var missingElements = [];
  var seenMissing = {};
  var relationshipsToAdd = []; // Array of {relationship, attractorElement}

  attractors.forEach(function (visualAttractor) {
    var attractorElement = visualAttractor.concept;
    var relatedInfo = getRelatedElementsWithRelationships(attractorElement);

    relatedInfo.forEach(function (info) {
      var relatedElement = info.element;
      var relationship = info.relationship;
      
      // Check if element has "no-auto-sync" property - skip if it does
      if (relatedElement.prop("no-auto-sync") != null) {
        console.log("    Skipping " + relatedElement.name + " (has no-auto-sync property)");
        return; // Skip this element
      }
      
      // Check if this element is not yet on the view
      if (!isElementOnView(view, relatedElement)) {
        if (!seenMissing[relatedElement.id]) {
          missingElements.push(relatedElement);
          seenMissing[relatedElement.id] = true;
        }
        // Store the relationship to add later
        relationshipsToAdd.push({
          relationship: relationship,
          attractorElement: attractorElement
        });
      }
    });
  });

  if (missingElements.length === 0) {
    console.log("  No missing elements found");
    return;
  }

  console.log(
    "  Found " + missingElements.length + " missing element(s) to add",
  );

  // Find or create "New Elements" group
  var newElementsGroup = findOrCreateNewElementsGroup(view);

  // Add missing elements to the group
  var xOffset = 20;
  var yOffset = 30;
  var elementWidth = 120;
  var elementHeight = 55;
  var spacing = 10;

  missingElements.forEach(function (element, index) {
    var x = xOffset;
    var y = yOffset + index * (elementHeight + spacing);

    var visualElement = newElementsGroup.add(
      element,
      x,
      y,
      elementWidth,
      elementHeight,
    );
    console.log("    Added: " + element.name + " (" + element.type + ")");
  });

  // Adjust group size to fit all elements
  var groupHeight =
    yOffset + missingElements.length * (elementHeight + spacing) + 20;
  newElementsGroup.bounds = {
    x: 10,
    y: 10,
    width: elementWidth + 2 * xOffset,
    height: Math.max(groupHeight, 100),
  };

  // Add visual connections for the relationships
  console.log("  Adding relationships...");
  var addedConnections = 0;
  relationshipsToAdd.forEach(function (relInfo) {
    var relationship = relInfo.relationship;
    var sourceElement = relationship.source;
    var targetElement = relationship.target;

    // Find visual objects for source and target
    var sourceVisual = findVisualObjectForElement(view, sourceElement);
    var targetVisual = findVisualObjectForElement(view, targetElement);

    if (sourceVisual && targetVisual) {
      // Add the visual connection
      view.add(relationship, sourceVisual, targetVisual);
      addedConnections++;
    }
  });
  console.log("  Added " + addedConnections + " relationship(s)");

  // Add "review-" prefix to view name if not already present
  if (!view.name.startsWith("review-")) {
    view.name = "review-" + view.name;
    console.log("  Renamed view to: " + view.name);
  }
}

// Main execution
var views = $("archimate-diagram-model");
console.log("\nFound " + views.size() + " ArchiMate view(s) to process\n");

views.each(function (view) {
  processView(view);
});

console.log("\n=== Sync completed ===");
