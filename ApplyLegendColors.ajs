/*
 * Apply Legend Colors to Elements
 *
 * This script finds all views with property "legend"="y" and applies the fill colors
 * of elements on these legend views to the same elements on all other views.
 *
 * Additionally, it applies colors to elements that are aggregated, composed, or associated
 * with the legend elements.
 *
 * If an element appears on multiple legend views, the color from the first legend view is used.
 *
 * (c) Y. Moldawski
 */

console.log("Starting Apply Legend Colors script...");

// Store element colors from legend views: elementId -> fillColor
var elementColors = {};

// Find all views with property "legend"="y"
var legendViews = $("view").filter(function (view) {
  return view.prop("legend") === "y";
});

console.log("Found " + legendViews.size() + " legend view(s)");

// Iterate through legend views and collect element colors
legendViews.each(function (view) {
  console.log("Processing legend view: " + view.name);

  // Get all visual objects in this view
  $(view)
    .find("element")
    .each(function (visualElement) {
      var elementId = visualElement.concept.id;
      var fillColor = visualElement.fillColor;

      // Only store color if we haven't seen this element yet (first legend view wins)
      if (!elementColors[elementId] && fillColor) {
        elementColors[elementId] = fillColor;
        console.log(
          "  - Stored color " +
            fillColor +
            " for element: " +
            visualElement.concept.name,
        );

        // Apply color recursively to aggregated and composed elements
        var element = visualElement.concept;
        applyColorRecursively(element, fillColor, {}, 1);
      }
    });
});

// Recursive function to apply color to aggregated and composed elements
// visited object prevents infinite loops in case of cycles
function applyColorRecursively(element, fillColor, visited, depth) {
  var elementId = element.id;

  // Avoid cycles - if we've already visited this element in this branch, stop
  if (visited[elementId]) {
    return;
  }

  // Mark this element as visited
  visited[elementId] = true;

  var indent = "    ".repeat(depth);

  // Get all relationships where this element is the source
  $(element)
    .rels()
    .each(function (rel) {
      var relType = rel.type;

      if (
        relType === "aggregation-relationship" ||
        relType === "composition-relationship"
      ) {
        var targetElement = rel.target;
        var targetId = targetElement.id;

        // Apply the same color to the related element (if not already set)
        if (!elementColors[targetId]) {
          elementColors[targetId] = fillColor;
          console.log(
            indent + "-> Related (" + relType + "): " + targetElement.name,
          );

          // Recursively process this element
          applyColorRecursively(targetElement, fillColor, visited, depth + 1);
        }
      } else if (relType === "association-relationship") {
        var targetElement = rel.target;
        var targetId = targetElement.id;

        // Apply color to associated elements (but don't recurse)
        if (!elementColors[targetId]) {
          elementColors[targetId] = fillColor;
          console.log(indent + "-> Associated: " + targetElement.name);
        }
      }
    });

  // Also check relationships where this element is the target
  $(element)
    .inRels()
    .each(function (rel) {
      var relType = rel.type;

      if (
        relType === "aggregation-relationship" ||
        relType === "composition-relationship"
      ) {
        var sourceElement = rel.source;
        var sourceId = sourceElement.id;

        // Apply the same color to the related element (if not already set)
        if (!elementColors[sourceId]) {
          elementColors[sourceId] = fillColor;
          console.log(
            indent + "<- Related (" + relType + "): " + sourceElement.name,
          );

          // Recursively process this element
          applyColorRecursively(sourceElement, fillColor, visited, depth + 1);
        }
      } else if (relType === "association-relationship") {
        var sourceElement = rel.source;
        var sourceId = sourceElement.id;

        // Apply color to associated elements (but don't recurse)
        if (!elementColors[sourceId]) {
          elementColors[sourceId] = fillColor;
          console.log(indent + "<- Associated: " + sourceElement.name);
        }
      }
    });
}

// Count how many elements we found colors for
var colorCount = Object.keys(elementColors).length;
console.log("\nCollected colors for " + colorCount + " element(s)");

if (colorCount === 0) {
  console.log("No elements with fill colors found on legend views. Exiting.");
} else {
  // Now apply these colors to all non-legend views
  var appliedCount = 0;

  $("view").each(function (view) {
    // Skip legend views - they should keep their original colors
    if (view.prop("legend") === "y") {
      console.log("Skipping legend view: " + view.name);
      return;
    }

    $(view)
      .find("element")
      .each(function (visualElement) {
        var elementId = visualElement.concept.id;

        if (elementColors[elementId]) {
          visualElement.fillColor = elementColors[elementId];
          appliedCount++;
        }
      });
  });

  console.log(
    "\nApplied colors to " +
      appliedCount +
      " visual element(s) across non-legend views",
  );
  console.log("Done!");
}
