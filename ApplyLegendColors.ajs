/*
 * Apply Legend Colors to Elements
 *
 * This script finds all views with property "legend"="y" and applies the fill, text, line, and icon colors
 * of elements on these legend views to the same elements on all other views.
 *
 * Additionally, it applies colors to parts of aggregated/composed elements (top-down)
 * and to associated elements (outgoing only) with the legend elements.
 *
 * If an element appears on multiple legend views, the colors from the first legend view are used.
 *
 * (c) Y. Moldawski
 */

console.log("Starting Apply Legend Colors script...");

// Store element colors from legend views: elementId -> {fillColor, fontColor, lineColor, iconColor}
var elementColors = {};

// Find all views with property "legend"="y"
var legendViews = $("view").filter(function (view) {
  return view.prop("legend") === "y";
});

console.log("Found " + legendViews.size() + " legend view(s)");

// Iterate through legend views and collect element colors
legendViews.each(function (view) {
  console.log("Processing legend view: " + view.name);

  // Get all visual objects in this view
  $(view)
    .find("element")
    .each(function (visualElement) {
      var elementId = visualElement.concept.id;
      var fillColor = visualElement.fillColor;
      var fontColor = visualElement.fontColor;
      var lineColor = visualElement.lineColor;
      var iconColor = visualElement.iconColor;

      // Only store colors if we haven't seen this element yet (first legend view wins)
      // Store if at least one color is defined
      if (!elementColors[elementId] && (fillColor || fontColor || lineColor || iconColor)) {
        elementColors[elementId] = {
          fillColor: fillColor,
          fontColor: fontColor,
          lineColor: lineColor,
          iconColor: iconColor
        };
        
        var colorInfo = [];
        if (fillColor) colorInfo.push("fill=" + fillColor);
        if (fontColor) colorInfo.push("font=" + fontColor);
        if (lineColor) colorInfo.push("line=" + lineColor);
        if (iconColor) colorInfo.push("icon=" + iconColor);
        
        console.log(
          "  - Stored colors (" +
            colorInfo.join(", ") +
            ") for element: " +
            visualElement.concept.name,
        );

        // Apply colors recursively to aggregated and composed elements
        var element = visualElement.concept;
        applyColorRecursively(element, elementColors[elementId], {}, 1);
      }
    });
});

// Recursive function to apply colors to aggregated and composed elements
// visited object prevents infinite loops in case of cycles
function applyColorRecursively(element, colors, visited, depth) {
  var elementId = element.id;

  // Avoid cycles - if we've already visited this element in this branch, stop
  if (visited[elementId]) {
    return;
  }

  // Mark this element as visited
  visited[elementId] = true;

  var indent = "    ".repeat(depth);

  // Get all relationships where this element is the source (top-down only)
  $(element)
    .rels()
    .each(function (rel) {
      var relType = rel.type;

      if (
        relType === "aggregation-relationship" ||
        relType === "composition-relationship"
      ) {
        var targetElement = rel.target;
        var targetId = targetElement.id;

        // Apply the same colors to the part/target element (if not already set)
        if (!elementColors[targetId]) {
          elementColors[targetId] = colors;
          console.log(
            indent + "-> Part (" + relType + "): " + targetElement.name,
          );

          // Recursively process this part
          applyColorRecursively(targetElement, colors, visited, depth + 1);
        }
      } else if (relType === "association-relationship") {
        var targetElement = rel.target;
        var targetId = targetElement.id;

        // Apply colors to associated elements (but don't recurse)
        if (!elementColors[targetId]) {
          elementColors[targetId] = colors;
          console.log(indent + "-> Associated: " + targetElement.name);
        }
      }
    });
}

// Count how many elements we found colors for
var colorCount = Object.keys(elementColors).length;
console.log("\nCollected colors for " + colorCount + " element(s)");

if (colorCount === 0) {
  console.log("No elements with fill colors found on legend views. Exiting.");
} else {
  // Now apply these colors to all non-legend views
  var appliedCount = 0;

  $("view").each(function (view) {
    // Skip legend views - they should keep their original colors
    if (view.prop("legend") === "y") {
      console.log("Skipping legend view: " + view.name);
      return;
    }

    $(view)
      .find("element")
      .each(function (visualElement) {
        var elementId = visualElement.concept.id;

        if (elementColors[elementId]) {
          var colors = elementColors[elementId];
          if (colors.fillColor) visualElement.fillColor = colors.fillColor;
          if (colors.fontColor) visualElement.fontColor = colors.fontColor;
          if (colors.lineColor) visualElement.lineColor = colors.lineColor;
          if (colors.iconColor) visualElement.iconColor = colors.iconColor;
          appliedCount++;
        }
      });
  });

  console.log(
    "\nApplied colors to " +
      appliedCount +
      " visual element(s) across non-legend views",
  );
  console.log("Done!");
}
